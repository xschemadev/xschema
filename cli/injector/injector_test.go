package injector

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/xschema/cli/generator"
	"github.com/xschema/cli/language"
)

func TestInject_TypeScript(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Name:    "User",
				Schema:  `z.object({ id: z.string(), name: z.string() })`,
				Type:    "z.infer<typeof User>",
				Imports: []string{`import { z } from "zod"`},
			},
			{
				Name:    "Post",
				Schema:  `z.object({ title: z.string(), body: z.string() })`,
				Type:    "z.infer<typeof Post>",
				Imports: []string{`import { z } from "zod"`},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	// Read output
	content, err := os.ReadFile(filepath.Join(tmpDir, "xschema.gen.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Check header
	if !strings.Contains(output, "Generated by xschema - DO NOT EDIT") {
		t.Error("Missing header")
	}

	// Check imports are merged (only one zod import)
	if strings.Count(output, `from "zod"`) != 1 {
		t.Error("Imports not properly merged")
	}

	// Check schemas
	if !strings.Contains(output, "export const User =") {
		t.Error("Missing User schema")
	}
	if !strings.Contains(output, "export const Post =") {
		t.Error("Missing Post schema")
	}

	// Check registry
	if !strings.Contains(output, "schemas = { User, Post }") {
		t.Error("Missing schema registry")
	}

	// Check declaration merging
	if !strings.Contains(output, `declare module '@xschema/client'`) {
		t.Error("Missing declaration merging")
	}
}

func TestInject_Python(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "python",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Name: "User",
				Schema: `class User(BaseModel):
    id: str
    name: str`,
				Type:    "User",
				Imports: []string{`from pydantic import BaseModel`},
			},
			{
				Name: "Post",
				Schema: `class Post(BaseModel):
    title: str
    body: str`,
				Type:    "Post",
				Imports: []string{`from pydantic import BaseModel`},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	// Read output
	content, err := os.ReadFile(filepath.Join(tmpDir, "__init__.py"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Check header
	if !strings.Contains(output, "Generated by xschema - DO NOT EDIT") {
		t.Error("Missing header")
	}

	// Check imports merged
	if strings.Count(output, "from pydantic import") != 1 {
		t.Error("Imports not properly merged")
	}

	// Check schemas
	if !strings.Contains(output, "class User(BaseModel):") {
		t.Error("Missing User schema")
	}
	if !strings.Contains(output, "class Post(BaseModel):") {
		t.Error("Missing Post schema")
	}

	// Check registry
	if !strings.Contains(output, `"User": User`) {
		t.Error("Missing User in registry")
	}

	// Check overloads
	if !strings.Contains(output, `Literal["User"]`) {
		t.Error("Missing User overload")
	}
	if !strings.Contains(output, "def from_url") {
		t.Error("Missing from_url method")
	}
}

func TestInject_UnsupportedLanguage(t *testing.T) {
	err := Inject(InjectInput{
		Language: "rust",
		OutDir:   t.TempDir(),
		Outputs:  []generator.GenerateOutput{},
	})

	if err == nil {
		t.Error("Expected error for unsupported language")
	}
	if !strings.Contains(err.Error(), "unsupported language") {
		t.Errorf("Unexpected error: %v", err)
	}
}

func TestInject_TypeOnly(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Name:    "User",
				Type:    "{ id: string; name: string }",
				Schema:  "", // type only, no schema
				Imports: []string{},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	content, err := os.ReadFile(filepath.Join(tmpDir, "xschema.gen.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Should have type export, not const
	if !strings.Contains(output, "export type User =") {
		t.Errorf("Missing type export, got:\n%s", output)
	}
	if strings.Contains(output, "export const User =") {
		t.Error("Should not have const export for type-only")
	}
}

func TestInject_SchemaOnly(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Name:    "User",
				Schema:  "z.object({ id: z.string() })",
				Type:    "", // schema only, no explicit type
				Imports: []string{`import { z } from "zod"`},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	content, err := os.ReadFile(filepath.Join(tmpDir, "xschema.gen.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Should have const export, not type
	if !strings.Contains(output, "export const User =") {
		t.Errorf("Missing const export, got:\n%s", output)
	}
	if strings.Contains(output, "export type User =") {
		t.Error("Should not have type export for schema-only")
	}
}

func TestInject_CreatesDirectory(t *testing.T) {
	tmpDir := t.TempDir()
	outDir := filepath.Join(tmpDir, "nested", ".xschema")

	err := Inject(InjectInput{
		Language: "typescript",
		OutDir:   outDir,
		Outputs: []generator.GenerateOutput{
			{Name: "Test", Schema: "z.string()", Imports: []string{}},
		},
	})

	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	if _, err := os.Stat(filepath.Join(outDir, "xschema.gen.ts")); os.IsNotExist(err) {
		t.Error("Output file not created")
	}
}

func TestInjectClient_TypeScript(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a client file
	clientContent := `import { createXSchemaClient } from "@xschema/client";
import { zodAdapter } from "@xschema/zod";

export const xschema = createXSchemaClient({
  output: ".xschema",
});

const User = xschema.fromURL("User", "https://example.com/user.json", zodAdapter);
`
	clientFile := filepath.Join(tmpDir, "main.ts")
	if err := os.WriteFile(clientFile, []byte(clientContent), 0644); err != nil {
		t.Fatalf("Failed to write client file: %v", err)
	}

	// Inject
	ctx := t.Context()
	lang := language.ByName("typescript")

	err := InjectClient(ctx, InjectClientInput{
		ClientFile: clientFile,
		Language:   lang,
		OutDir:     ".xschema",
	})
	if err != nil {
		t.Fatalf("InjectClient failed: %v", err)
	}

	// Read result
	content, err := os.ReadFile(clientFile)
	if err != nil {
		t.Fatalf("Failed to read client file: %v", err)
	}

	output := string(content)

	// Check import added (with or without ./ prefix)
	if !strings.Contains(output, `import { schemas } from ".xschema/xschema.gen"`) &&
		!strings.Contains(output, `import { schemas } from "./.xschema/xschema.gen"`) {
		t.Errorf("Missing schemas import, got:\n%s", output)
	}

	// Check schemas added to config
	if !strings.Contains(output, "{ schemas,") || !strings.Contains(output, "output:") {
		t.Errorf("Missing schemas in config, got:\n%s", output)
	}
}

func TestInjectClient_EmptyConfig(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a client file with empty config
	clientContent := `import { createXSchemaClient } from "@xschema/client";

export const xschema = createXSchemaClient({});
`
	clientFile := filepath.Join(tmpDir, "main.ts")
	if err := os.WriteFile(clientFile, []byte(clientContent), 0644); err != nil {
		t.Fatalf("Failed to write client file: %v", err)
	}

	ctx := t.Context()
	lang := language.ByName("typescript")

	err := InjectClient(ctx, InjectClientInput{
		ClientFile: clientFile,
		Language:   lang,
		OutDir:     ".xschema",
	})
	if err != nil {
		t.Fatalf("InjectClient failed: %v", err)
	}

	content, err := os.ReadFile(clientFile)
	if err != nil {
		t.Fatalf("Failed to read client file: %v", err)
	}

	output := string(content)

	// Check schemas added
	if !strings.Contains(output, "{ schemas }") {
		t.Errorf("Missing schemas in empty config, got:\n%s", output)
	}
}

func TestInjectClient_ExistingSchemasShorthand(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a client file with existing schemas shorthand
	clientContent := `import { createXSchemaClient } from "@xschema/client";
import { schemas } from ".xschema/xschema.gen";

export const xschema = createXSchemaClient({ schemas, output: ".xschema" });
`
	clientFile := filepath.Join(tmpDir, "main.ts")
	if err := os.WriteFile(clientFile, []byte(clientContent), 0644); err != nil {
		t.Fatalf("Failed to write client file: %v", err)
	}

	ctx := t.Context()
	lang := language.ByName("typescript")

	err := InjectClient(ctx, InjectClientInput{
		ClientFile: clientFile,
		Language:   lang,
		OutDir:     ".xschema",
	})
	if err != nil {
		t.Fatalf("InjectClient failed: %v", err)
	}

	content, err := os.ReadFile(clientFile)
	if err != nil {
		t.Fatalf("Failed to read client file: %v", err)
	}

	output := string(content)

	// Check schemas not duplicated (should still be shorthand)
	if !strings.Contains(output, "{ schemas,") {
		t.Errorf("Schemas shorthand should not be modified, got:\n%s", output)
	}
}

func TestInjectClient_ExistingSchemasPair(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a client file with existing schemas as key-value pair
	clientContent := `import { createXSchemaClient } from "@xschema/client";
import { schemas } from ".xschema/xschema.gen";

export const xschema = createXSchemaClient({ schemas: schemas, output: ".xschema" });
`
	clientFile := filepath.Join(tmpDir, "main.ts")
	if err := os.WriteFile(clientFile, []byte(clientContent), 0644); err != nil {
		t.Fatalf("Failed to write client file: %v", err)
	}

	ctx := t.Context()
	lang := language.ByName("typescript")

	err := InjectClient(ctx, InjectClientInput{
		ClientFile: clientFile,
		Language:   lang,
		OutDir:     ".xschema",
	})
	if err != nil {
		t.Fatalf("InjectClient failed: %v", err)
	}

	content, err := os.ReadFile(clientFile)
	if err != nil {
		t.Fatalf("Failed to read client file: %v", err)
	}

	output := string(content)

	// Check schemas not duplicated (should still be key-value pair)
	if !strings.Contains(output, "{ schemas: schemas,") {
		t.Errorf("Schemas pair should not be modified, got:\n%s", output)
	}
}
