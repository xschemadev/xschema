package injector

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/xschemadev/xschema/generator"
	"github.com/xschemadev/xschema/language"
)

func TestInject_TypeScript(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Namespace: "user",
				ID:        "User",
				Schema:    `z.object({ id: z.string(), name: z.string() })`,
				Type:      "z.infer<typeof user_User>",
				Imports:   []string{`import { z } from "zod"`},
			},
			{
				Namespace: "user",
				ID:        "Post",
				Schema:    `z.object({ title: z.string(), body: z.string() })`,
				Type:      "z.infer<typeof user_Post>",
				Imports:   []string{`import { z } from "zod"`},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	// Read output
	content, err := os.ReadFile(filepath.Join(tmpDir, "xschema.gen.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Check header
	if !strings.Contains(output, "Generated by xschema - DO NOT EDIT") {
		t.Error("Missing header")
	}

	// Check imports are merged (only one zod import)
	if strings.Count(output, `from "zod"`) != 1 {
		t.Error("Imports not properly merged")
	}

	// Check schemas with namespaced variable names
	if !strings.Contains(output, "const user_User =") {
		t.Error("Missing user_User schema")
	}
	if !strings.Contains(output, "const user_Post =") {
		t.Error("Missing user_Post schema")
	}

	// Check registry with namespace:id keys
	if !strings.Contains(output, `"user:User": user_User`) {
		t.Error("Missing user:User in schema registry")
	}
	if !strings.Contains(output, `"user:Post": user_Post`) {
		t.Error("Missing user:Post in schema registry")
	}

	// Check declaration merging
	if !strings.Contains(output, `declare module '@xschema/client'`) {
		t.Error("Missing declaration merging")
	}
}

func TestInject_Python(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "python",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Namespace: "user",
				ID:        "User",
				Schema: `class user_User(BaseModel):
    id: str
    name: str`,
				Type:    "user_User",
				Imports: []string{`from pydantic import BaseModel`},
			},
			{
				Namespace: "user",
				ID:        "Post",
				Schema: `class user_Post(BaseModel):
    title: str
    body: str`,
				Type:    "user_Post",
				Imports: []string{`from pydantic import BaseModel`},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	// Read output
	content, err := os.ReadFile(filepath.Join(tmpDir, "__init__.py"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Check header
	if !strings.Contains(output, "Generated by xschema - DO NOT EDIT") {
		t.Error("Missing header")
	}

	// Check imports merged
	if strings.Count(output, "from pydantic import") != 1 {
		t.Error("Imports not properly merged")
	}

	// Check schemas
	if !strings.Contains(output, "class user_User(BaseModel):") {
		t.Error("Missing user_User schema")
	}
	if !strings.Contains(output, "class user_Post(BaseModel):") {
		t.Error("Missing user_Post schema")
	}

	// Check registry with namespace:id keys
	if !strings.Contains(output, `"user:User": user_User`) {
		t.Error("Missing user:User in registry")
	}

	// Check overloads with namespace:id format
	if !strings.Contains(output, `Literal["user:User"]`) {
		t.Error("Missing user:User overload")
	}
	if !strings.Contains(output, "def from_url") {
		t.Error("Missing from_url method")
	}
}

func TestInject_UnsupportedLanguage(t *testing.T) {
	err := Inject(InjectInput{
		Language: "rust",
		OutDir:   t.TempDir(),
		Outputs:  []generator.GenerateOutput{},
	})

	if err == nil {
		t.Error("Expected error for unsupported language")
	}
	if !strings.Contains(err.Error(), "unsupported language") {
		t.Errorf("Unexpected error: %v", err)
	}
}

func TestInject_TypeOnly(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Namespace: "user",
				ID:        "User",
				Type:      "{ id: string; name: string }",
				Schema:    "", // type only, no schema
				Imports:   []string{},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	content, err := os.ReadFile(filepath.Join(tmpDir, "xschema.gen.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Should have type export, not const
	if !strings.Contains(output, "export type user_User =") {
		t.Errorf("Missing type export, got:\n%s", output)
	}
	if strings.Contains(output, "const user_User =") {
		t.Error("Should not have const export for type-only")
	}
}

func TestInject_SchemaOnly(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Namespace: "user",
				ID:        "User",
				Schema:    "z.object({ id: z.string() })",
				Type:      "", // schema only, no explicit type
				Imports:   []string{`import { z } from "zod"`},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	content, err := os.ReadFile(filepath.Join(tmpDir, "xschema.gen.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Should have const export, not type
	if !strings.Contains(output, "const user_User =") {
		t.Errorf("Missing const export, got:\n%s", output)
	}
	if strings.Contains(output, "export type user_User =") {
		t.Error("Should not have type export for schema-only")
	}
}

func TestInject_CreatesDirectory(t *testing.T) {
	tmpDir := t.TempDir()
	outDir := filepath.Join(tmpDir, "nested", ".xschema")

	err := Inject(InjectInput{
		Language: "typescript",
		OutDir:   outDir,
		Outputs: []generator.GenerateOutput{
			{Namespace: "test", ID: "Test", Schema: "z.string()", Imports: []string{}},
		},
	})

	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	if _, err := os.Stat(filepath.Join(outDir, "xschema.gen.ts")); os.IsNotExist(err) {
		t.Error("Output file not created")
	}
}

func TestInjectClient_TypeScript(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a client file
	clientContent := `import { createXSchemaClient } from "@xschema/client";

export const xschema = createXSchemaClient({
  defaultNamespace: "user",
});
`
	clientFile := filepath.Join(tmpDir, "main.ts")
	if err := os.WriteFile(clientFile, []byte(clientContent), 0644); err != nil {
		t.Fatalf("Failed to write client file: %v", err)
	}

	// Inject
	lang := language.ByName("typescript")

	err := InjectClient(InjectClientInput{
		ClientFile: clientFile,
		Language:   lang,
		OutDir:     ".xschema",
	})
	if err != nil {
		t.Fatalf("InjectClient failed: %v", err)
	}

	// Read result
	content, err := os.ReadFile(clientFile)
	if err != nil {
		t.Fatalf("Failed to read client file: %v", err)
	}

	output := string(content)

	// Check import added (with or without ./ prefix)
	if !strings.Contains(output, `import { schemas } from ".xschema/xschema.gen"`) &&
		!strings.Contains(output, `import { schemas } from "./.xschema/xschema.gen"`) {
		t.Errorf("Missing schemas import, got:\n%s", output)
	}

	// Check schemas added to config
	if !strings.Contains(output, "{ schemas,") || !strings.Contains(output, "defaultNamespace:") {
		t.Errorf("Missing schemas in config, got:\n%s", output)
	}
}

func TestInjectClient_EmptyConfig(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a client file with empty config
	clientContent := `import { createXSchemaClient } from "@xschema/client";

export const xschema = createXSchemaClient({});
`
	clientFile := filepath.Join(tmpDir, "main.ts")
	if err := os.WriteFile(clientFile, []byte(clientContent), 0644); err != nil {
		t.Fatalf("Failed to write client file: %v", err)
	}

	lang := language.ByName("typescript")

	err := InjectClient(InjectClientInput{
		ClientFile: clientFile,
		Language:   lang,
		OutDir:     ".xschema",
	})
	if err != nil {
		t.Fatalf("InjectClient failed: %v", err)
	}

	content, err := os.ReadFile(clientFile)
	if err != nil {
		t.Fatalf("Failed to read client file: %v", err)
	}

	output := string(content)

	// Check schemas added
	if !strings.Contains(output, "{ schemas }") {
		t.Errorf("Missing schemas in empty config, got:\n%s", output)
	}
}

func TestInjectClient_ExistingSchemasShorthand(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a client file with existing schemas shorthand
	clientContent := `import { createXSchemaClient } from "@xschema/client";
import { schemas } from ".xschema/xschema.gen";

export const xschema = createXSchemaClient({ schemas, defaultNamespace: "user" });
`
	clientFile := filepath.Join(tmpDir, "main.ts")
	if err := os.WriteFile(clientFile, []byte(clientContent), 0644); err != nil {
		t.Fatalf("Failed to write client file: %v", err)
	}

	lang := language.ByName("typescript")

	err := InjectClient(InjectClientInput{
		ClientFile: clientFile,
		Language:   lang,
		OutDir:     ".xschema",
	})
	if err != nil {
		t.Fatalf("InjectClient failed: %v", err)
	}

	content, err := os.ReadFile(clientFile)
	if err != nil {
		t.Fatalf("Failed to read client file: %v", err)
	}

	output := string(content)

	// Check schemas not duplicated (should still be shorthand)
	if !strings.Contains(output, "{ schemas,") {
		t.Errorf("Schemas shorthand should not be modified, got:\n%s", output)
	}
}

func TestInjectClient_ExistingSchemasPair(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a client file with existing schemas as key-value pair
	clientContent := `import { createXSchemaClient } from "@xschema/client";
import { schemas } from ".xschema/xschema.gen";

export const xschema = createXSchemaClient({ schemas: schemas, defaultNamespace: "user" });
`
	clientFile := filepath.Join(tmpDir, "main.ts")
	if err := os.WriteFile(clientFile, []byte(clientContent), 0644); err != nil {
		t.Fatalf("Failed to write client file: %v", err)
	}

	lang := language.ByName("typescript")

	err := InjectClient(InjectClientInput{
		ClientFile: clientFile,
		Language:   lang,
		OutDir:     ".xschema",
	})
	if err != nil {
		t.Fatalf("InjectClient failed: %v", err)
	}

	content, err := os.ReadFile(clientFile)
	if err != nil {
		t.Fatalf("Failed to read client file: %v", err)
	}

	output := string(content)

	// Check schemas not duplicated (should still be key-value pair)
	if !strings.Contains(output, "{ schemas: schemas,") {
		t.Errorf("Schemas pair should not be modified, got:\n%s", output)
	}
}

func TestInject_EmptyOutputs(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs:  []generator.GenerateOutput{},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	// File should still be created with header
	content, err := os.ReadFile(filepath.Join(tmpDir, "xschema.gen.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)
	if !strings.Contains(output, "Generated by xschema") {
		t.Error("Missing header in empty output file")
	}
}

func TestInject_MixedSchemaAndType(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Namespace: "user",
				ID:        "WithBoth",
				Schema:    `z.object({ id: z.string() })`,
				Type:      "z.infer<typeof user_WithBoth>",
				Imports:   []string{`import { z } from "zod"`},
			},
			{
				Namespace: "user",
				ID:        "TypeOnly",
				Schema:    "",
				Type:      "{ id: string }",
				Imports:   []string{},
			},
			{
				Namespace: "user",
				ID:        "SchemaOnly",
				Schema:    `z.string()`,
				Type:      "",
				Imports:   []string{`import { z } from "zod"`},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	content, err := os.ReadFile(filepath.Join(tmpDir, "xschema.gen.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Check all three schemas are present
	if !strings.Contains(output, "user_WithBoth") {
		t.Error("Missing WithBoth schema")
	}
	if !strings.Contains(output, "user_TypeOnly") {
		t.Error("Missing TypeOnly schema")
	}
	if !strings.Contains(output, "user_SchemaOnly") {
		t.Error("Missing SchemaOnly schema")
	}
}

func TestInject_MultipleNamespaces(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{Namespace: "user", ID: "User", Schema: "z.string()", Imports: []string{`import { z } from "zod"`}},
			{Namespace: "post", ID: "Post", Schema: "z.number()", Imports: []string{`import { z } from "zod"`}},
			{Namespace: "comment", ID: "Comment", Schema: "z.boolean()", Imports: []string{`import { z } from "zod"`}},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	content, err := os.ReadFile(filepath.Join(tmpDir, "xschema.gen.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Check all namespaced keys
	if !strings.Contains(output, `"user:User"`) {
		t.Error("Missing user:User key")
	}
	if !strings.Contains(output, `"post:Post"`) {
		t.Error("Missing post:Post key")
	}
	if !strings.Contains(output, `"comment:Comment"`) {
		t.Error("Missing comment:Comment key")
	}
}

func TestInject_DifferentImports(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Namespace: "user",
				ID:        "User",
				Schema:    "z.string()",
				Imports:   []string{`import { z } from "zod"`, `import { ZodError } from "zod"`},
			},
			{
				Namespace: "user",
				ID:        "Post",
				Schema:    "someOther()",
				Imports:   []string{`import { someOther } from "other-lib"`},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	content, err := os.ReadFile(filepath.Join(tmpDir, "xschema.gen.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Check imports are merged correctly
	if !strings.Contains(output, `from "zod"`) {
		t.Error("Missing zod import")
	}
	if !strings.Contains(output, `from "other-lib"`) {
		t.Error("Missing other-lib import")
	}
}

func TestInject_OverwriteExisting(t *testing.T) {
	tmpDir := t.TempDir()
	outPath := filepath.Join(tmpDir, "xschema.gen.ts")

	// Write existing file
	if err := os.WriteFile(outPath, []byte("// old content"), 0644); err != nil {
		t.Fatalf("Failed to write existing file: %v", err)
	}

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{Namespace: "user", ID: "New", Schema: "z.string()", Imports: []string{}},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	content, err := os.ReadFile(outPath)
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Old content should be replaced
	if strings.Contains(output, "old content") {
		t.Error("Old content should be overwritten")
	}
	if !strings.Contains(output, "user_New") {
		t.Error("New content should be present")
	}
}

func TestInjectClient_NoClientFactory(t *testing.T) {
	tmpDir := t.TempDir()

	// File without createXSchemaClient
	clientContent := `import { something } from "somewhere";

export const foo = "bar";
`
	clientFile := filepath.Join(tmpDir, "main.ts")
	if err := os.WriteFile(clientFile, []byte(clientContent), 0644); err != nil {
		t.Fatalf("Failed to write client file: %v", err)
	}

	lang := language.ByName("typescript")

	err := InjectClient(InjectClientInput{
		ClientFile: clientFile,
		Language:   lang,
		OutDir:     ".xschema",
	})
	if err != nil {
		t.Fatalf("InjectClient failed: %v", err)
	}

	content, err := os.ReadFile(clientFile)
	if err != nil {
		t.Fatalf("Failed to read client file: %v", err)
	}

	output := string(content)

	// Should still add import even without factory
	if !strings.Contains(output, `import { schemas }`) {
		t.Error("Should add schemas import")
	}
}

func TestInjectClient_FileNotFound(t *testing.T) {
	lang := language.ByName("typescript")

	err := InjectClient(InjectClientInput{
		ClientFile: "/nonexistent/path/main.ts",
		Language:   lang,
		OutDir:     ".xschema",
	})

	if err == nil {
		t.Error("Expected error for non-existent file")
	}
}

func TestInject_NilLanguage(t *testing.T) {
	err := Inject(InjectInput{
		Language: "",
		OutDir:   t.TempDir(),
		Outputs:  []generator.GenerateOutput{},
	})

	if err == nil {
		t.Error("Expected error for empty language")
	}
}
