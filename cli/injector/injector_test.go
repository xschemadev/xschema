package injector

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/xschema/cli/generator"
)

func TestInject_TypeScript(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Name:    "User",
				Schema:  `z.object({ id: z.string(), name: z.string() })`,
				Type:    "z.infer<typeof User>",
				Imports: []string{`import { z } from "zod"`},
			},
			{
				Name:    "Post",
				Schema:  `z.object({ title: z.string(), body: z.string() })`,
				Type:    "z.infer<typeof Post>",
				Imports: []string{`import { z } from "zod"`},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	// Read output
	content, err := os.ReadFile(filepath.Join(tmpDir, "index.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Check header
	if !strings.Contains(output, "Generated by xschema - DO NOT EDIT") {
		t.Error("Missing header")
	}

	// Check imports are merged (only one zod import)
	if strings.Count(output, `from "zod"`) != 1 {
		t.Error("Imports not properly merged")
	}

	// Check schemas
	if !strings.Contains(output, "export const User =") {
		t.Error("Missing User schema")
	}
	if !strings.Contains(output, "export const Post =") {
		t.Error("Missing Post schema")
	}

	// Check registry
	if !strings.Contains(output, "schemas = { User, Post }") {
		t.Error("Missing schema registry")
	}

	// Check runtime re-export
	if !strings.Contains(output, `from '@xschema/runtime'`) {
		t.Error("Missing runtime import")
	}
}

func TestInject_Python(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "python",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Name: "User",
				Schema: `class User(BaseModel):
    id: str
    name: str`,
				Type:    "User",
				Imports: []string{`from pydantic import BaseModel`},
			},
			{
				Name: "Post",
				Schema: `class Post(BaseModel):
    title: str
    body: str`,
				Type:    "Post",
				Imports: []string{`from pydantic import BaseModel`},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	// Read output
	content, err := os.ReadFile(filepath.Join(tmpDir, "__init__.py"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Check header
	if !strings.Contains(output, "Generated by xschema - DO NOT EDIT") {
		t.Error("Missing header")
	}

	// Check imports merged
	if strings.Count(output, "from pydantic import") != 1 {
		t.Error("Imports not properly merged")
	}

	// Check schemas
	if !strings.Contains(output, "class User(BaseModel):") {
		t.Error("Missing User schema")
	}
	if !strings.Contains(output, "class Post(BaseModel):") {
		t.Error("Missing Post schema")
	}

	// Check registry
	if !strings.Contains(output, `"User": User`) {
		t.Error("Missing User in registry")
	}

	// Check overloads
	if !strings.Contains(output, `Literal["User"]`) {
		t.Error("Missing User overload")
	}
	if !strings.Contains(output, "def from_url") {
		t.Error("Missing from_url method")
	}
}

func TestInject_UnsupportedLanguage(t *testing.T) {
	err := Inject(InjectInput{
		Language: "rust",
		OutDir:   t.TempDir(),
		Outputs:  []generator.GenerateOutput{},
	})

	if err == nil {
		t.Error("Expected error for unsupported language")
	}
	if !strings.Contains(err.Error(), "unsupported language") {
		t.Errorf("Unexpected error: %v", err)
	}
}

func TestInject_TypeOnly(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Name:    "User",
				Type:    "{ id: string; name: string }",
				Schema:  "", // type only, no schema
				Imports: []string{},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	content, err := os.ReadFile(filepath.Join(tmpDir, "index.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Should have type export, not const
	if !strings.Contains(output, "export type User =") {
		t.Errorf("Missing type export, got:\n%s", output)
	}
	if strings.Contains(output, "export const User =") {
		t.Error("Should not have const export for type-only")
	}
}

func TestInject_SchemaOnly(t *testing.T) {
	tmpDir := t.TempDir()

	input := InjectInput{
		Language: "typescript",
		OutDir:   tmpDir,
		Outputs: []generator.GenerateOutput{
			{
				Name:    "User",
				Schema:  "z.object({ id: z.string() })",
				Type:    "", // schema only, no explicit type
				Imports: []string{`import { z } from "zod"`},
			},
		},
	}

	err := Inject(input)
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	content, err := os.ReadFile(filepath.Join(tmpDir, "index.ts"))
	if err != nil {
		t.Fatalf("Failed to read output: %v", err)
	}

	output := string(content)

	// Should have const export, not type
	if !strings.Contains(output, "export const User =") {
		t.Errorf("Missing const export, got:\n%s", output)
	}
	if strings.Contains(output, "export type User =") {
		t.Error("Should not have type export for schema-only")
	}
}

func TestInject_CreatesDirectory(t *testing.T) {
	tmpDir := t.TempDir()
	outDir := filepath.Join(tmpDir, "nested", ".xschema")

	err := Inject(InjectInput{
		Language: "typescript",
		OutDir:   outDir,
		Outputs: []generator.GenerateOutput{
			{Name: "Test", Schema: "z.string()", Imports: []string{}},
		},
	})

	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	if _, err := os.Stat(filepath.Join(outDir, "index.ts")); os.IsNotExist(err) {
		t.Error("Output file not created")
	}
}
