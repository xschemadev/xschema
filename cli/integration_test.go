package main

import (
	"context"
	"encoding/json"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/xschema/cli/generator"
	"github.com/xschema/cli/injector"
	"github.com/xschema/cli/parser"
	"github.com/xschema/cli/retriever"
)

// TestIntegration_FullPipeline tests the complete flow:
// Parse -> Retrieve -> Generate -> Inject
func TestIntegration_FullPipeline(t *testing.T) {
	// Skip in short mode since it requires adapter
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	// Setup: create temp project structure
	tmpDir := t.TempDir()

	// Create schema files
	userSchema := `{
		"type": "object",
		"properties": {
			"id": {"type": "string"},
			"name": {"type": "string"},
			"email": {"type": "string", "format": "email"}
		},
		"required": ["id", "name"]
	}`
	postSchema := `{
		"type": "object",
		"properties": {
			"title": {"type": "string"},
			"body": {"type": "string"}
		},
		"required": ["title"]
	}`

	schemasDir := filepath.Join(tmpDir, "schemas")
	if err := os.MkdirAll(schemasDir, 0755); err != nil {
		t.Fatalf("failed to create schemas dir: %v", err)
	}
	if err := os.WriteFile(filepath.Join(schemasDir, "user.json"), []byte(userSchema), 0644); err != nil {
		t.Fatalf("failed to write user schema: %v", err)
	}
	if err := os.WriteFile(filepath.Join(schemasDir, "post.json"), []byte(postSchema), 0644); err != nil {
		t.Fatalf("failed to write post schema: %v", err)
	}

	// Create xschema config file
	configContent := `{
		"$schema": "https://xschema.dev/schemas/ts.jsonc",
		"namespace": "api",
		"schemas": [
			{
				"id": "User",
				"sourceType": "file",
				"source": "user.json",
				"adapter": "@xschema/zod"
			},
			{
				"id": "Post",
				"sourceType": "file",
				"source": "post.json",
				"adapter": "@xschema/zod"
			},
			{
				"id": "InlineSchema",
				"sourceType": "json",
				"source": {"type": "string", "minLength": 1},
				"adapter": "@xschema/zod"
			}
		]
	}`
	if err := os.WriteFile(filepath.Join(schemasDir, "api.jsonc"), []byte(configContent), 0644); err != nil {
		t.Fatalf("failed to write config: %v", err)
	}

	// Copy node_modules from generator testdata for adapter
	generatorTestdata := filepath.Join("generator", "testdata", "typescript")
	if _, err := os.Stat(generatorTestdata); os.IsNotExist(err) {
		t.Skip("generator testdata not found - run from cli directory")
	}

	// Change to generator testdata for adapter access
	originalDir, _ := os.Getwd()
	if err := os.Chdir(generatorTestdata); err != nil {
		t.Fatalf("failed to chdir: %v", err)
	}
	defer os.Chdir(originalDir)

	ctx := context.Background()

	// Step 1: Parse
	result, err := parser.Parse(ctx, schemasDir, "")
	if err != nil {
		t.Fatalf("Parse failed: %v", err)
	}

	if len(result.Declarations) != 3 {
		t.Fatalf("expected 3 declarations, got %d", len(result.Declarations))
	}
	if result.Language.Name != "typescript" {
		t.Errorf("expected typescript, got %s", result.Language.Name)
	}

	// Step 2: Retrieve
	schemas, err := retriever.Retrieve(ctx, result.Declarations, retriever.DefaultOptions())
	if err != nil {
		t.Fatalf("Retrieve failed: %v", err)
	}

	if len(schemas) != 3 {
		t.Fatalf("expected 3 schemas, got %d", len(schemas))
	}

	// Verify schema content
	for _, s := range schemas {
		if !json.Valid(s.Schema) {
			t.Errorf("invalid JSON for schema %s", s.Key())
		}
	}

	// Step 3: Generate
	outputs, err := generator.GenerateAll(ctx, schemas, result.Language.Name)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if len(outputs) != 3 {
		t.Fatalf("expected 3 outputs, got %d", len(outputs))
	}

	// Verify generated code
	for _, o := range outputs {
		if o.Schema == "" {
			t.Errorf("empty schema for %s", o.Key())
		}
		if !strings.Contains(o.Schema, "z.") {
			t.Errorf("expected zod schema, got: %s", o.Schema)
		}
	}

	// Step 4: Inject
	outDir := filepath.Join(tmpDir, ".xschema")
	err = injector.Inject(injector.InjectInput{
		Language: result.Language.Name,
		OutDir:   outDir,
		Outputs:  outputs,
	})
	if err != nil {
		t.Fatalf("Inject failed: %v", err)
	}

	// Verify output file
	outPath := filepath.Join(outDir, "xschema.gen.ts")
	content, err := os.ReadFile(outPath)
	if err != nil {
		t.Fatalf("failed to read output: %v", err)
	}

	output := string(content)

	// Check for expected content
	checks := []string{
		"Generated by xschema",
		`"api:User"`,
		`"api:Post"`,
		`"api:InlineSchema"`,
		"api_User",
		"api_Post",
		"api_InlineSchema",
		`from "zod"`,
		"z.object",
	}

	for _, check := range checks {
		if !strings.Contains(output, check) {
			t.Errorf("missing expected content: %s", check)
		}
	}
}

// TestIntegration_MultipleConfigs tests parsing multiple config files
func TestIntegration_MultipleConfigs(t *testing.T) {
	tmpDir := t.TempDir()

	// Create two config files with different namespaces
	config1 := `{
		"$schema": "https://xschema.dev/schemas/ts.jsonc",
		"schemas": [
			{"id": "User", "sourceType": "json", "source": {"type": "string"}, "adapter": "@xschema/zod"}
		]
	}`
	config2 := `{
		"$schema": "https://xschema.dev/schemas/ts.jsonc",
		"schemas": [
			{"id": "Post", "sourceType": "json", "source": {"type": "number"}, "adapter": "@xschema/zod"}
		]
	}`

	if err := os.WriteFile(filepath.Join(tmpDir, "users.jsonc"), []byte(config1), 0644); err != nil {
		t.Fatalf("failed to write config1: %v", err)
	}
	if err := os.WriteFile(filepath.Join(tmpDir, "posts.jsonc"), []byte(config2), 0644); err != nil {
		t.Fatalf("failed to write config2: %v", err)
	}

	ctx := context.Background()
	result, err := parser.Parse(ctx, tmpDir, "")
	if err != nil {
		t.Fatalf("Parse failed: %v", err)
	}

	// Should have 2 configs with different namespaces (derived from filenames)
	if len(result.Configs) != 2 {
		t.Errorf("expected 2 configs, got %d", len(result.Configs))
	}

	byNs := result.DeclarationsByNamespace()
	if len(byNs) != 2 {
		t.Errorf("expected 2 namespaces, got %d", len(byNs))
	}
	if _, ok := byNs["users"]; !ok {
		t.Error("expected 'users' namespace")
	}
	if _, ok := byNs["posts"]; !ok {
		t.Error("expected 'posts' namespace")
	}
}

// TestIntegration_InlineJSONPassthrough tests inline JSON schemas
func TestIntegration_InlineJSONPassthrough(t *testing.T) {
	tmpDir := t.TempDir()

	inlineSchema := `{"type": "object", "properties": {"test": {"type": "boolean"}}}`
	config := `{
		"$schema": "https://xschema.dev/schemas/ts.jsonc",
		"schemas": [
			{"id": "Inline", "sourceType": "json", "source": ` + inlineSchema + `, "adapter": "@xschema/zod"}
		]
	}`

	if err := os.WriteFile(filepath.Join(tmpDir, "test.jsonc"), []byte(config), 0644); err != nil {
		t.Fatalf("failed to write config: %v", err)
	}

	ctx := context.Background()
	result, err := parser.Parse(ctx, tmpDir, "")
	if err != nil {
		t.Fatalf("Parse failed: %v", err)
	}

	schemas, err := retriever.Retrieve(ctx, result.Declarations, retriever.DefaultOptions())
	if err != nil {
		t.Fatalf("Retrieve failed: %v", err)
	}

	// Inline schema should be passed through as-is
	if string(schemas[0].Schema) != inlineSchema {
		t.Errorf("inline schema not passed through correctly: %s", schemas[0].Schema)
	}
}

// TestIntegration_AdapterGrouping tests that schemas are grouped by adapter
func TestIntegration_AdapterGrouping(t *testing.T) {
	tmpDir := t.TempDir()

	config := `{
		"$schema": "https://xschema.dev/schemas/ts.jsonc",
		"schemas": [
			{"id": "Zod1", "sourceType": "json", "source": {"type": "string"}, "adapter": "@xschema/zod"},
			{"id": "Zod2", "sourceType": "json", "source": {"type": "number"}, "adapter": "@xschema/zod"},
			{"id": "Other1", "sourceType": "json", "source": {"type": "boolean"}, "adapter": "@xschema/other"},
			{"id": "Other2", "sourceType": "json", "source": {"type": "null"}, "adapter": "@xschema/other"}
		]
	}`

	if err := os.WriteFile(filepath.Join(tmpDir, "test.jsonc"), []byte(config), 0644); err != nil {
		t.Fatalf("failed to write config: %v", err)
	}

	ctx := context.Background()
	result, err := parser.Parse(ctx, tmpDir, "")
	if err != nil {
		t.Fatalf("Parse failed: %v", err)
	}

	schemas, err := retriever.Retrieve(ctx, result.Declarations, retriever.DefaultOptions())
	if err != nil {
		t.Fatalf("Retrieve failed: %v", err)
	}

	groups := retriever.GroupByAdapter(schemas)
	if len(groups) != 2 {
		t.Errorf("expected 2 adapter groups, got %d", len(groups))
	}
	if len(groups["@xschema/zod"]) != 2 {
		t.Errorf("expected 2 zod schemas, got %d", len(groups["@xschema/zod"]))
	}
	if len(groups["@xschema/other"]) != 2 {
		t.Errorf("expected 2 other schemas, got %d", len(groups["@xschema/other"]))
	}

	// Sorted adapters should be deterministic
	sorted := retriever.SortedAdapters(groups)
	if sorted[0] != "@xschema/other" || sorted[1] != "@xschema/zod" {
		t.Errorf("unexpected sort order: %v", sorted)
	}
}
